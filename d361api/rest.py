"""
    Document360 Customer API

    Document360 RESTful APIs will allow you to integrate your documentation with your software, allowing you to easily onboard new users, manage your articles and more.   You can find detailed API documentation here : [API Documentation](https://apidocs.document360.io/docs)

    The version of the OpenAPI document: 2.0
    Contact: support@document360.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import io
import json
import re
import ssl
from typing import Any, Mapping

import httpx # Replaced aiohttp
from d361api.exceptions import ApiException, ApiValueError

RESTResponseType = httpx.Response # Replaced aiohttp.ClientResponse

# httpx uses these methods for its internal retry mechanism by default
# For more complex retry strategies, httpx relies on event hooks or external libraries like tenacity
# We will use httpx's built-in retries via AsyncHTTPTransport
RETRY_METHODS = frozenset({'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PUT', 'TRACE'})


class RESTResponse(io.IOBase):
    def __init__(self, resp: httpx.Response) -> None:
        self.response: httpx.Response = resp
        self.status: int = resp.status_code # Changed from resp.status
        self.reason: str = resp.reason_phrase # Changed from resp.reason
        self.data: bytes | None = None # Will be populated by read()

    async def read(self) -> bytes:
        if self.data is None:
            await self.response.aread() # Ensure stream is consumed
            self.data = self.response.content
        return self.data

    def getheaders(self) -> httpx.Headers:
        """Returns httpx.Headers object of the response headers."""
        return self.response.headers

    def getheader(self, name: str, default: str | None = None) -> str | None: # Typed default
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:
    def __init__(self, configuration) -> None:
        self.configuration = configuration
        self.maxsize = configuration.connection_pool_maxsize # Used for httpx limits

        # SSL Configuration for httpx
        # httpx uses 'verify' and 'cert' parameters in its client or transport
        ssl_context = httpx.create_ssl_context(
            cafile=configuration.ssl_ca_cert,
            certfile=configuration.cert_file,
            keyfile=configuration.key_file,
        )
        if not configuration.verify_ssl:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

        self.verify_ssl = ssl_context if configuration.verify_ssl else False


        proxies = {"all://": configuration.proxy} if configuration.proxy else None
        self.proxies = proxies


        # Retry Configuration for httpx
        # httpx.AsyncHTTPTransport can take a 'retries' argument.
        transport_retries = 0
        if configuration.retries is not None:
            transport_retries = configuration.retries

        # httpx Client Initialization
        limits = httpx.Limits(
            max_connections=self.maxsize or None,
            max_keepalive_connections=20 # A reasonable default for keep-alive
        )

        transport = httpx.AsyncHTTPTransport(
            verify=self.httpx_verify_param, # Use the correctly prepared SSLContext or False
            retries=transport_retries,
            limits=limits
        )

        # If mypy complains about proxies, it might be a stub issue. httpx.AsyncClient does accept it.
        self.client: httpx.AsyncClient = httpx.AsyncClient(
            proxies=self.proxies, # type: ignore[call-arg]
            transport=transport,
            follow_redirects=True,
            timeout=httpx.Timeout(5 * 60.0) # Default timeout
        )

    async def close(self) -> None:
        await self.client.aclose()

    async def request(
        self,
        method: str,
        url: str,
        headers: Mapping[str, str] | None = None,
        body: Any | None = None, # Can be dict for json, str, bytes, etc.
        post_params: list[tuple[str, Any]] | None = None, # For form data
        _request_timeout: float | httpx.Timeout | None = None
    ) -> RESTResponse:
        method = method.upper()
        assert method in [
            'GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS'
        ]

        if post_params and body is not None and not (isinstance(body, (str,bytes)) and not body) and not (isinstance(body, dict) and not body):
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter unless body is empty or for JSON."
            )


        headers = headers or {}
        timeout = _request_timeout if _request_timeout is not None else self.client.timeout

        # Prepare request arguments for httpx
        request_args: dict[str, Any] = {
            "method": method,
            "url": url,
            "headers": headers,
            "timeout": timeout,
        }

        # Content/Body handling
        content_type = headers.get('Content-Type', 'application/json').lower()

        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
            if post_params: # Form data
                if 'multipart/form-data' in content_type:
                    # httpx handles multipart from dict of files or data
                    # files = {k: (filename, content, content_type) or file_like_object}
                    # data = {k: v} for simple fields
                    # We expect post_params to be list of tuples (key, value)
                    # where value can be (filename, filedata, mimetype) for files
                    httpx_files = {}
                    httpx_data = {}
                    for k, v_item in post_params:
                        if isinstance(v_item, tuple) and len(v_item) == 3: # (filename, filedata, mimetype)
                            httpx_files[k] = (v_item[0], v_item[1], v_item[2])
                        elif isinstance(v_item, tuple) and len(v_item) == 2 and hasattr(v_item[1], 'read'): # (filename, file_like_object)
                             httpx_files[k] = (v_item[0], v_item[1], None) # Explicitly None for content_type
                        else: # simple data field
                            httpx_data[k] = str(v_item) if isinstance(v_item, (dict, list, int, float)) else v_item

                    if httpx_files:
                        request_args["files"] = httpx_files
                    if httpx_data: # Can send data fields along with files
                        request_args["data"] = httpx_data
                    # httpx will set Content-Type for multipart, remove if set
                    if 'Content-Type' in request_args.get("headers", {}):
                        del request_args["headers"]['Content-Type']

                elif 'application/x-www-form-urlencoded' in content_type:
                    # Convert list of tuples to dict for httpx's data param
                    request_args["data"] = {k: str(v) if isinstance(v, (dict, list, int, float)) else v for k, v in post_params}
                else: # Potentially other form types, pass post_params as data
                    request_args["data"] = {k: str(v) if isinstance(v, (dict, list, int, float)) else v for k, v in post_params}

            elif body is not None:
                if 'application/json' in content_type:
                    request_args["json"] = body # httpx handles serialization for json
                elif isinstance(body, (str, bytes)):
                    request_args["content"] = body
                else:
                    # If body is some other serializable object but not for JSON,
                    # it should be pre-serialized to str or bytes.
                    # This case might need more specific handling based on expected types.
                    msg = "Body must be dict for JSON, or str/bytes for other content types."
                    raise ApiException(status=0, reason=msg)

        try:
            response = await self.client.request(**request_args)
            # No need to manually raise_for_status, ApiException.from_response will handle it
        except httpx.RequestError as e: # Catches network errors, timeout, etc.
            # Map httpx exceptions to ApiException or a new specific exception type if needed
            url = getattr(e.request, "url", None) if hasattr(e, "request") else request_args.get("url")
            url_info = f" URL: {url}" if url else ""
            raise ApiException(
                status=0,
                reason=f"HTTPX RequestError ({e.__class__.__name__}){url_info} - {e}"
            )

        return RESTResponse(response)

