"""
    Document360 Customer API

    Document360 RESTful APIs will allow you to integrate your documentation with your software, allowing you to easily onboard new users, manage your articles and more.   You can find detailed API documentation here : [API Documentation](https://apidocs.document360.io/docs)

    The version of the OpenAPI document: 2.0
    Contact: support@document360.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""

from datetime import datetime
from typing import Annotated, Any

from d361api.api_client import ApiClient, RequestSerialized
from d361api.api_response import ApiResponse
from d361api.models.add_media_file_response_customer import \
    AddMediaFileResponseCustomer
from d361api.models.add_media_folder_request_customer import \
    AddMediaFolderRequestCustomer
from d361api.models.all_files_with_count_response_customer import \
    AllFilesWithCountResponseCustomer
from d361api.models.customer_api_base_response import CustomerApiBaseResponse
from d361api.models.delete_media_file_response_customer import \
    DeleteMediaFileResponseCustomer
from d361api.models.get_customer_task_status_response import \
    GetCustomerTaskStatusResponse
from d361api.models.get_drive_files_in_article_data_customer import \
    GetDriveFilesInArticleDataCustomer
from d361api.models.get_media_folder_response_customer import \
    GetMediaFolderResponseCustomer
from d361api.models.get_media_folder_with_id_customer import \
    GetMediaFolderWithIdCustomer
from d361api.models.media_file_and_tags_meta_data_response_customer import \
    MediaFileAndTagsMetaDataResponseCustomer
from d361api.models.media_file_data_response_customer import \
    MediaFileDataResponseCustomer
from d361api.models.media_folder_meta_data_response_customer import \
    MediaFolderMetaDataResponseCustomer
from d361api.models.update_media_folder_request_customer import \
    UpdateMediaFolderRequestCustomer
from d361api.rest import RESTResponseType
from pydantic import (Field, StrictBool, StrictBytes, StrictFloat, StrictInt,
                      StrictStr, validate_call)


class DriveApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def v2_drive_folders_delete_file_status_task_id_get(
        self,
        task_id: Annotated[StrictStr, Field(description="The task ID of the file deleted")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCustomerTaskStatusResponse:
        """Get status of the delete file operation


        :param task_id: The task ID of the file deleted (required)
        :type task_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_delete_file_status_task_id_get_serialize(
            task_id=task_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetCustomerTaskStatusResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_delete_file_status_task_id_get_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The task ID of the file deleted")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCustomerTaskStatusResponse]:
        """Get status of the delete file operation


        :param task_id: The task ID of the file deleted (required)
        :type task_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_delete_file_status_task_id_get_serialize(
            task_id=task_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetCustomerTaskStatusResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_delete_file_status_task_id_get_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The task ID of the file deleted")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get status of the delete file operation


        :param task_id: The task ID of the file deleted (required)
        :type task_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_delete_file_status_task_id_get_serialize(
            task_id=task_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetCustomerTaskStatusResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_delete_file_status_task_id_get_serialize(
        self,
        task_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/Folders/DeleteFile/Status/{taskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_files_post(
        self,
        drive_folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        user_id: Annotated[StrictStr, Field(description="The ID of the team account")],
        files: Annotated[list[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes]], Field(description="File collection -The maximum file size upload limit is 40MB")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AddMediaFileResponseCustomer:
        """Add file in to drive


        :param drive_folder_id: The folder ID (required)
        :type drive_folder_id: str
        :param user_id: The ID of the team account (required)
        :type user_id: str
        :param files: File collection -The maximum file size upload limit is 40MB (required)
        :type files: List[bytearray]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_files_post_serialize(
            drive_folder_id=drive_folder_id,
            user_id=user_id,
            files=files,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AddMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_files_post_with_http_info(
        self,
        drive_folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        user_id: Annotated[StrictStr, Field(description="The ID of the team account")],
        files: Annotated[list[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes]], Field(description="File collection -The maximum file size upload limit is 40MB")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AddMediaFileResponseCustomer]:
        """Add file in to drive


        :param drive_folder_id: The folder ID (required)
        :type drive_folder_id: str
        :param user_id: The ID of the team account (required)
        :type user_id: str
        :param files: File collection -The maximum file size upload limit is 40MB (required)
        :type files: List[bytearray]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_files_post_serialize(
            drive_folder_id=drive_folder_id,
            user_id=user_id,
            files=files,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AddMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_files_post_without_preload_content(
        self,
        drive_folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        user_id: Annotated[StrictStr, Field(description="The ID of the team account")],
        files: Annotated[list[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes]], Field(description="File collection -The maximum file size upload limit is 40MB")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add file in to drive


        :param drive_folder_id: The folder ID (required)
        :type drive_folder_id: str
        :param user_id: The ID of the team account (required)
        :type user_id: str
        :param files: File collection -The maximum file size upload limit is 40MB (required)
        :type files: List[bytearray]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_files_post_serialize(
            drive_folder_id=drive_folder_id,
            user_id=user_id,
            files=files,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AddMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_files_post_serialize(
        self,
        drive_folder_id,
        user_id,
        files,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'files': 'multi',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if drive_folder_id is not None:

            _query_params.append(('DriveFolderId', drive_folder_id))

        if user_id is not None:

            _query_params.append(('UserId', user_id))

        # process the header parameters
        # process the form parameters
        if files is not None:
            _files['files'] = files
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/Drive/Folders/Files',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_delete(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Delete a folder


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_delete_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_delete_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Delete a folder


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_delete_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_delete_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a folder


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_delete_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_delete_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/Drive/Folders/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_copy_post(
        self,
        folder_id: Annotated[StrictStr, Field(description="Target folder ID")],
        file_id: Annotated[StrictStr, Field(description="Selected file ID")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Copy file from one folder to another


        :param folder_id: Target folder ID (required)
        :type folder_id: str
        :param file_id: Selected file ID (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_copy_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_copy_post_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="Target folder ID")],
        file_id: Annotated[StrictStr, Field(description="Selected file ID")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Copy file from one folder to another


        :param folder_id: Target folder ID (required)
        :type folder_id: str
        :param file_id: Selected file ID (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_copy_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_copy_post_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="Target folder ID")],
        file_id: Annotated[StrictStr, Field(description="Selected file ID")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Copy file from one folder to another


        :param folder_id: Target folder ID (required)
        :type folder_id: str
        :param file_id: Selected file ID (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_copy_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_copy_post_serialize(
        self,
        folder_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}/Copy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_delete(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteMediaFileResponseCustomer:
        """Delete file using file ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param file_id: The ID of the file in Drive (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_delete_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "DeleteMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_delete_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteMediaFileResponseCustomer]:
        """Delete file using file ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param file_id: The ID of the file in Drive (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_delete_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "DeleteMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_delete_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        file_id: Annotated[StrictStr, Field(description="The ID of the file in Drive")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete file using file ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param file_id: The ID of the file in Drive (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_delete_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "DeleteMediaFileResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_delete_serialize(
        self,
        folder_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_get(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaFileAndTagsMetaDataResponseCustomer:
        """Gets file information


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_get_serialize(
            folder_id=folder_id,
            file_id=file_id,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileAndTagsMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_get_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaFileAndTagsMetaDataResponseCustomer]:
        """Gets file information


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_get_serialize(
            folder_id=folder_id,
            file_id=file_id,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileAndTagsMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_get_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets file information


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_get_serialize(
            folder_id=folder_id,
            file_id=file_id,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileAndTagsMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_get_serialize(
        self,
        folder_id,
        file_id,
        append_sas_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if append_sas_token is not None:

            _query_params.append(('appendSASToken', append_sas_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_put(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of target folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerApiBaseResponse:
        """Move a file with file ID


        :param folder_id: The ID of target folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_put_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_put_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of target folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerApiBaseResponse]:
        """Move a file with file ID


        :param folder_id: The ID of target folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_put_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_put_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of target folder")],
        file_id: Annotated[StrictStr, Field(description="The ID of file")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Move a file with file ID


        :param folder_id: The ID of target folder (required)
        :type folder_id: str
        :param file_id: The ID of file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_put_serialize(
            folder_id=folder_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "CustomerApiBaseResponse",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_put_serialize(
        self,
        folder_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_bulkdelete_post(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag Ids")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaFileDataResponseCustomer:
        """Delete tags from files


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag Ids (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag Ids")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaFileDataResponseCustomer]:
        """Delete tags from files


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag Ids (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag Ids")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete tags from files


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag Ids (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_tags_bulkdelete_post_serialize(
        self,
        folder_id,
        file_id,
        user_id,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'request_body': '',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if user_id is not None:

            _query_params.append(('userId', user_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json',
                        'application/json',
                        'text/json',
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}/Tags/Bulkdelete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_post(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag names")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaFileDataResponseCustomer:
        """Add tags in a file using file ID


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag names (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_post_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag names")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaFileDataResponseCustomer]:
        """Add tags in a file using file ID


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag names (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_file_id_tags_post_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The folder ID")],
        file_id: Annotated[StrictStr, Field(description="The file ID")],
        user_id: Annotated[StrictStr, Field(description="Team account ID")],
        request_body: Annotated[list[StrictStr], Field(description="List of tag names")],
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add tags in a file using file ID


        :param folder_id: The folder ID (required)
        :type folder_id: str
        :param file_id: The file ID (required)
        :type file_id: str
        :param user_id: Team account ID (required)
        :type user_id: str
        :param request_body: List of tag names (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_file_id_tags_post_serialize(
            folder_id=folder_id,
            file_id=file_id,
            user_id=user_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFileDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_file_id_tags_post_serialize(
        self,
        folder_id,
        file_id,
        user_id,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'request_body': '',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if user_id is not None:

            _query_params.append(('userId', user_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json',
                        'application/json',
                        'text/json',
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/Drive/Folders/{folderId}/{fileId}/Tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_folder_id_get(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMediaFolderWithIdCustomer:
        """Gets folder information by folder ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_get_serialize(
            folder_id=folder_id,
            append_sas_token=append_sas_token,
            page_no=page_no,
            take=take,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderWithIdCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_folder_id_get_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMediaFolderWithIdCustomer]:
        """Gets folder information by folder ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_get_serialize(
            folder_id=folder_id,
            append_sas_token=append_sas_token,
            page_no=page_no,
            take=take,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderWithIdCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_folder_id_get_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of the folder in Drive")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets folder information by folder ID


        :param folder_id: The ID of the folder in Drive (required)
        :type folder_id: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_folder_id_get_serialize(
            folder_id=folder_id,
            append_sas_token=append_sas_token,
            page_no=page_no,
            take=take,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderWithIdCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_folder_id_get_serialize(
        self,
        folder_id,
        append_sas_token,
        page_no,
        take,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        if append_sas_token is not None:

            _query_params.append(('appendSASToken', append_sas_token))

        if page_no is not None:

            _query_params.append(('pageNo', page_no))

        if take is not None:

            _query_params.append(('take', take))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/Folders/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_get(
        self,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMediaFolderResponseCustomer:
        """Gets folders information


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_get_with_http_info(
        self,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMediaFolderResponseCustomer]:
        """Gets folders information


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_get_without_preload_content(
        self,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets folders information


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetMediaFolderResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/Folders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_post(
        self,
        add_media_folder_request_customer: AddMediaFolderRequestCustomer | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaFolderMetaDataResponseCustomer:
        """Add new folder in drive


        :param add_media_folder_request_customer: 
        :type add_media_folder_request_customer: AddMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_post_serialize(
            add_media_folder_request_customer=add_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_post_with_http_info(
        self,
        add_media_folder_request_customer: AddMediaFolderRequestCustomer | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaFolderMetaDataResponseCustomer]:
        """Add new folder in drive


        :param add_media_folder_request_customer: 
        :type add_media_folder_request_customer: AddMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_post_serialize(
            add_media_folder_request_customer=add_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_post_without_preload_content(
        self,
        add_media_folder_request_customer: AddMediaFolderRequestCustomer | None = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add new folder in drive


        :param add_media_folder_request_customer: 
        :type add_media_folder_request_customer: AddMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_post_serialize(
            add_media_folder_request_customer=add_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_post_serialize(
        self,
        add_media_folder_request_customer,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_media_folder_request_customer is not None:
            _body_params = add_media_folder_request_customer


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json',
                        'application/json',
                        'text/json',
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/Drive/Folders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_folders_put(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        update_media_folder_request_customer: UpdateMediaFolderRequestCustomer,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaFolderMetaDataResponseCustomer:
        """Update a folder with ID


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param update_media_folder_request_customer: (required)
        :type update_media_folder_request_customer: UpdateMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_put_serialize(
            folder_id=folder_id,
            update_media_folder_request_customer=update_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_folders_put_with_http_info(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        update_media_folder_request_customer: UpdateMediaFolderRequestCustomer,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaFolderMetaDataResponseCustomer]:
        """Update a folder with ID


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param update_media_folder_request_customer: (required)
        :type update_media_folder_request_customer: UpdateMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_put_serialize(
            folder_id=folder_id,
            update_media_folder_request_customer=update_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_folders_put_without_preload_content(
        self,
        folder_id: Annotated[StrictStr, Field(description="The ID of drive folder")],
        update_media_folder_request_customer: UpdateMediaFolderRequestCustomer,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a folder with ID


        :param folder_id: The ID of drive folder (required)
        :type folder_id: str
        :param update_media_folder_request_customer: (required)
        :type update_media_folder_request_customer: UpdateMediaFolderRequestCustomer
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_folders_put_serialize(
            folder_id=folder_id,
            update_media_folder_request_customer=update_media_folder_request_customer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "MediaFolderMetaDataResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_folders_put_serialize(
        self,
        folder_id,
        update_media_folder_request_customer,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if folder_id is not None:

            _query_params.append(('folderId', folder_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_media_folder_request_customer is not None:
            _body_params = update_media_folder_request_customer


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json-patch+json',
                        'application/json',
                        'text/json',
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v2/Drive/Folders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_media_files_project_version_id_article_id_lang_code_get(
        self,
        project_version_id: Annotated[StrictStr, Field(description="The ID of the project version")],
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDriveFilesInArticleDataCustomer:
        """Get all media files inserted in the article


        :param project_version_id: The ID of the project version (required)
        :type project_version_id: str
        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_media_files_project_version_id_article_id_lang_code_get_serialize(
            project_version_id=project_version_id,
            article_id=article_id,
            lang_code=lang_code,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetDriveFilesInArticleDataCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_media_files_project_version_id_article_id_lang_code_get_with_http_info(
        self,
        project_version_id: Annotated[StrictStr, Field(description="The ID of the project version")],
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDriveFilesInArticleDataCustomer]:
        """Get all media files inserted in the article


        :param project_version_id: The ID of the project version (required)
        :type project_version_id: str
        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_media_files_project_version_id_article_id_lang_code_get_serialize(
            project_version_id=project_version_id,
            article_id=article_id,
            lang_code=lang_code,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetDriveFilesInArticleDataCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_media_files_project_version_id_article_id_lang_code_get_without_preload_content(
        self,
        project_version_id: Annotated[StrictStr, Field(description="The ID of the project version")],
        article_id: Annotated[StrictStr, Field(description="The ID of the article")],
        lang_code: Annotated[StrictStr, Field(description="Language code of the article")],
        append_sas_token: Annotated[StrictBool | None, Field(description="Set this to false to exclude appending SAS token for images/files")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all media files inserted in the article


        :param project_version_id: The ID of the project version (required)
        :type project_version_id: str
        :param article_id: The ID of the article (required)
        :type article_id: str
        :param lang_code: Language code of the article (required)
        :type lang_code: str
        :param append_sas_token: Set this to false to exclude appending SAS token for images/files
        :type append_sas_token: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_media_files_project_version_id_article_id_lang_code_get_serialize(
            project_version_id=project_version_id,
            article_id=article_id,
            lang_code=lang_code,
            append_sas_token=append_sas_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "GetDriveFilesInArticleDataCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_media_files_project_version_id_article_id_lang_code_get_serialize(
        self,
        project_version_id,
        article_id,
        lang_code,
        append_sas_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if project_version_id is not None:
            _path_params['projectVersionId'] = project_version_id
        if article_id is not None:
            _path_params['articleId'] = article_id
        if lang_code is not None:
            _path_params['langCode'] = lang_code
        # process the query parameters
        if append_sas_token is not None:

            _query_params.append(('appendSASToken', append_sas_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/MediaFiles/{projectVersionId}/{articleId}/{langCode}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def v2_drive_search_get(
        self,
        search_keyword: Annotated[StrictStr | None, Field(description="Keyword to search file items from drive")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        allow_images_only: Annotated[StrictBool | None, Field(description="Allow images only in response")] = None,
        user_ids: Annotated[list[StrictStr] | None, Field(description="Find by userId")] = None,
        filter_from_date: Annotated[datetime | None, Field(description="Filter using from-date")] = None,
        filter_to_date: Annotated[datetime | None, Field(description="Filter using to-date")] = None,
        filter_tags: Annotated[list[StrictStr] | None, Field(description="Filter using tagIds")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AllFilesWithCountResponseCustomer:
        """Drive search - files and folders


        :param search_keyword: Keyword to search file items from drive
        :type search_keyword: str
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param allow_images_only: Allow images only in response
        :type allow_images_only: bool
        :param user_ids: Find by userId
        :type user_ids: List[str]
        :param filter_from_date: Filter using from-date
        :type filter_from_date: datetime
        :param filter_to_date: Filter using to-date
        :type filter_to_date: datetime
        :param filter_tags: Filter using tagIds
        :type filter_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_search_get_serialize(
            search_keyword=search_keyword,
            page_no=page_no,
            take=take,
            allow_images_only=allow_images_only,
            user_ids=user_ids,
            filter_from_date=filter_from_date,
            filter_to_date=filter_to_date,
            filter_tags=filter_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AllFilesWithCountResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def v2_drive_search_get_with_http_info(
        self,
        search_keyword: Annotated[StrictStr | None, Field(description="Keyword to search file items from drive")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        allow_images_only: Annotated[StrictBool | None, Field(description="Allow images only in response")] = None,
        user_ids: Annotated[list[StrictStr] | None, Field(description="Find by userId")] = None,
        filter_from_date: Annotated[datetime | None, Field(description="Filter using from-date")] = None,
        filter_to_date: Annotated[datetime | None, Field(description="Filter using to-date")] = None,
        filter_tags: Annotated[list[StrictStr] | None, Field(description="Filter using tagIds")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AllFilesWithCountResponseCustomer]:
        """Drive search - files and folders


        :param search_keyword: Keyword to search file items from drive
        :type search_keyword: str
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param allow_images_only: Allow images only in response
        :type allow_images_only: bool
        :param user_ids: Find by userId
        :type user_ids: List[str]
        :param filter_from_date: Filter using from-date
        :type filter_from_date: datetime
        :param filter_to_date: Filter using to-date
        :type filter_to_date: datetime
        :param filter_tags: Filter using tagIds
        :type filter_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_search_get_serialize(
            search_keyword=search_keyword,
            page_no=page_no,
            take=take,
            allow_images_only=allow_images_only,
            user_ids=user_ids,
            filter_from_date=filter_from_date,
            filter_to_date=filter_to_date,
            filter_tags=filter_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AllFilesWithCountResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def v2_drive_search_get_without_preload_content(
        self,
        search_keyword: Annotated[StrictStr | None, Field(description="Keyword to search file items from drive")] = None,
        page_no: Annotated[StrictInt | None, Field(description="Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9")] = None,
        take: Annotated[StrictInt | None, Field(description="The number of results per page")] = None,
        allow_images_only: Annotated[StrictBool | None, Field(description="Allow images only in response")] = None,
        user_ids: Annotated[list[StrictStr] | None, Field(description="Find by userId")] = None,
        filter_from_date: Annotated[datetime | None, Field(description="Filter using from-date")] = None,
        filter_to_date: Annotated[datetime | None, Field(description="Filter using to-date")] = None,
        filter_tags: Annotated[list[StrictStr] | None, Field(description="Filter using tagIds")] = None,
        _request_timeout: (
            None |
            Annotated[StrictFloat, Field(gt=0)] |
            tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ) = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Drive search - files and folders


        :param search_keyword: Keyword to search file items from drive
        :type search_keyword: str
        :param page_no: Specify the page to retrieve. Page numbers are zero-based. Therefore, to retrieve the 10th page, you need to set page=9
        :type page_no: int
        :param take: The number of results per page
        :type take: int
        :param allow_images_only: Allow images only in response
        :type allow_images_only: bool
        :param user_ids: Find by userId
        :type user_ids: List[str]
        :param filter_from_date: Filter using from-date
        :type filter_from_date: datetime
        :param filter_to_date: Filter using to-date
        :type filter_to_date: datetime
        :param filter_tags: Filter using tagIds
        :type filter_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._v2_drive_search_get_serialize(
            search_keyword=search_keyword,
            page_no=page_no,
            take=take,
            allow_images_only=allow_images_only,
            user_ids=user_ids,
            filter_from_date=filter_from_date,
            filter_to_date=filter_to_date,
            filter_tags=filter_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            '200': "AllFilesWithCountResponseCustomer",
            '400': "CustomerApiBaseResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _v2_drive_search_get_serialize(
        self,
        search_keyword,
        page_no,
        take,
        allow_images_only,
        user_ids,
        filter_from_date,
        filter_to_date,
        filter_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            'userIds': 'multi',
            'filterTags': 'multi',
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if search_keyword is not None:

            _query_params.append(('searchKeyword', search_keyword))

        if page_no is not None:

            _query_params.append(('pageNo', page_no))

        if take is not None:

            _query_params.append(('take', take))

        if allow_images_only is not None:

            _query_params.append(('allowImagesOnly', allow_images_only))

        if user_ids is not None:

            _query_params.append(('userIds', user_ids))

        if filter_from_date is not None:
            if isinstance(filter_from_date, datetime):
                _query_params.append(
                    (
                        'filterFromDate',
                        filter_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('filterFromDate', filter_from_date))

        if filter_to_date is not None:
            if isinstance(filter_to_date, datetime):
                _query_params.append(
                    (
                        'filterToDate',
                        filter_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('filterToDate', filter_to_date))

        if filter_tags is not None:

            _query_params.append(('filterTags', filter_tags))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            'api_token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/Drive/Search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


